<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Создать задачу — СкладСборка</title>
  <style>
    :root { --bg: #0f172a; --card:#111827; --text:#e5e7eb; --muted:#94a3b8; --accent:#22c55e; --warn:#f59e0b; --bad:#ef4444; }
    *{box-sizing:border-box} html,body{margin:0;height:100%}
    body{font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;background:linear-gradient(180deg,#0b1022,#0f172a);color:var(--text)}
    .container{max-width:1100px;margin:0 auto;padding:24px}
    .card{background:var(--card);border:1px solid #1f2937;border-radius:16px;padding:20px}
    h1{margin:0 0 8px 0} .muted{color:var(--muted)}
    .row{display:flex;gap:16px;flex-wrap:wrap}
    .col{flex:1 1 320px}
    .drop{border:2px dashed #334155;border-radius:16px;padding:24px;text-align:center;cursor:pointer;min-height:140px;display:flex;align-items:center;justify-content:center}
    .drop.drag{background:#0b1224}
    .btn{background:#1f2937;color:#fff;border:1px solid #334155;border-radius:10px;padding:10px 14px;cursor:pointer}
    .btn.primary{background:#2563eb;border-color:#1d4ed8}
    .btn.success{background:#16a34a;border-color:#15803d}
    .btn.warn{background:#f59e0b;border-color:#d97706}
    .btn:disabled{opacity:.6;cursor:not-allowed}
    input[type=text], textarea{width:100%;padding:10px;border-radius:10px;border:1px solid #334155;background:#0b1022;color:#fff}
    textarea{min-height:90px;resize:vertical}
    table{width:100%;border-collapse:collapse;font-size:14px}
    th,td{border-bottom:1px solid #1f2937;padding:8px 10px}
    th{position:sticky;top:0;background:#0b1022;z-index:1}
    tr.bad td{background:rgba(239,68,68,.08)}
    td[contenteditable="true"]{outline:1px dashed transparent}
    td[contenteditable="true"]:focus{outline:1px dashed #60a5fa;background:#0b1224}
    td.lowconf{background:rgba(245,158,11,.2)}
    .right{text-align:right}
    .status{min-height:24px}
    .footer{opacity:.7;font-size:12px;margin-top:12px}
    .hidden{display:none}
    .preview{font-size:13px;color:#cbd5e1}
    .sumrow td{font-weight:600;border-top:2px solid #334155}
    .grid{display:grid;grid-template-columns:repeat(4,1fr);gap:12px}
    @media (max-width:900px){.grid{grid-template-columns:1fr 1fr}}
    @media (max-width:640px){.grid{grid-template-columns:1fr}}
  </style>

  <!-- PDF.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script>pdfjsLib.GlobalWorkerOptions.workerSrc="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";</script>
  <!-- Tesseract.js (rus+eng) -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
</head>
<body>
<div class="container">
  <h1>Создать задачу</h1>
  <div class="muted">Перетащи PDF/изображение, либо вставь скрин Ctrl+V. PDF с текстовым слоем парсится без OCR.</div>

  <div class="row" style="margin-top:16px">
    <div class="col">
      <div id="drop" class="drop">
        <div>
          <div style="font-weight:600">Перетащи файл сюда</div>
          <div class="muted">или нажми, чтобы выбрать</div>
          <div class="preview" id="preview"></div>
        </div>
        <input id="file" type="file" accept=".pdf,.png,.jpg,.jpeg" class="hidden"/>
      </div>
      <div style="margin-top:12px; display:flex; gap:8px; align-items:center">
        <button class="btn" id="btn-clear">Очистить</button>
        <span id="status" class="status muted"></span>
      </div>
    </div>

    <div class="col">
      <div class="card">
        <div class="grid">
          <div>
            <div class="muted">Заголовок*</div>
            <input id="title" type="text" placeholder="Напр.: Заказ 1234 / Иванов"/>
          </div>
          <div>
            <div class="muted">Исполнители (UID через запятую)</div>
            <input id="assignees" type="text" placeholder="uid1,uid2"/>
          </div>
          <div style="grid-column: 1 / -1;">
            <div class="muted">Комментарий</div>
            <textarea id="comment" placeholder="Автоматически сюда добавим метаданные из шапки, при наличии."></textarea>
          </div>
        </div>
      </div>
      <div style="margin-top:12px; display:flex; gap:8px">
        <button class="btn primary" id="btn-parse">Распознать</button>
        <button class="btn success" id="btn-create" disabled>Создать задачу</button>
      </div>
      <div class="footer">Минимум 1 позиция → кнопка «Создать задачу» станет активной.</div>
    </div>
  </div>

  <div class="card" style="margin-top:16px">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px">
      <div style="font-weight:600">Позиции</div>
      <div class="muted" id="foundInfo">—</div>
    </div>
    <div style="overflow:auto; max-height:45vh">
      <table id="tbl">
        <thead>
          <tr>
            <th style="width:44%">Товар</th>
            <th style="width:16%">Артикул</th>
            <th class="right" style="width:14%">Упаковок</th>
            <th class="right" style="width:14%">Шт</th>
            <th style="width:12%"></th>
          </tr>
        </thead>
        <tbody id="tbody"></tbody>
        <tfoot>
          <tr class="sumrow">
            <td class="right" colspan="2">Итого:</td>
            <td class="right" id="sumPacks">0</td>
            <td class="right" id="sumUnits">0</td>
            <td></td>
          </tr>
        </tfoot>
      </table>
    </div>
  </div>

</div>

<script type="module">
  // ====== ЗАПОЛНИТЕ ПОД СЕБЯ ======
  const CLOUD_NAME    = "dnx1taqp7";
  const UPLOAD_PRESET = "unsigned_tasks"; // ваш unsigned upload preset
  const NOTIFY_URL    = "https://skladsborka-notify.vercel.app/api/notify-taskCreated"; // ваш эндпойнт/прокси

  // Firebase (Auth anon + Firestore)
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-app.js";
  import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-auth.js";
  import { getFirestore, collection, addDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-firestore.js";

  const firebaseConfig = {
    apiKey:      "PASTE",
    authDomain:  "PASTE.firebaseapp.com",
    projectId:   "PASTE",
    appId:       "PASTE"
  };

  const fbApp = initializeApp(firebaseConfig);
  const auth  = getAuth(fbApp);
  const db    = getFirestore(fbApp);
  await signInAnonymously(auth).catch(console.error);

  // ====== Утиль ======
  const $  = (s)=>document.querySelector(s);
  const $$ = (s)=>document.querySelectorAll(s);
  const status = (t)=>{ $("#status").textContent = t||""; };
  const textNormalize = (s)=> (s||"").replace(/\s+/g," ").trim();
  const numMaybe = (s)=> {
    if (s==null) return null;
    const t = String(s).replace(',', '.').replace(/\s/g,'').match(/-?\d+(\.\d+)?/);
    return t ? parseFloat(t[0]) : null;
  };

  // ====== Состояние ======
  let sourceFile = null;
  let sourceKind = null; // "pdf-text" | "pdf-scan" | "image"
  let parsedItems = [];

  // ====== UI элементы ======
  const drop      = $("#drop");
  const fileInput = $("#file");
  const btnParse  = $("#btn-parse");
  const btnClear  = $("#btn-clear");
  const btnCreate = $("#btn-create");
  const tbody     = $("#tbody");
  const sumPacks  = $("#sumPacks");
  const sumUnits  = $("#sumUnits");
  const foundInfo = $("#foundInfo");
  const preview   = $("#preview");

  // ====== Drag & Drop / File select / Paste ======
  drop.addEventListener("click", ()=> fileInput.click());
  drop.addEventListener("dragover",(e)=>{ e.preventDefault(); drop.classList.add("drag"); });
  drop.addEventListener("dragleave",()=> drop.classList.remove("drag"));
  drop.addEventListener("drop",(e)=>{
    e.preventDefault();
    drop.classList.remove("drag");
    if (!e.dataTransfer.files?.length) return;
    takeFile(e.dataTransfer.files[0]);
  });
  fileInput.addEventListener("change", (e)=> {
    if (e.target.files?.length) takeFile(e.target.files[0]);
  });
  window.addEventListener("paste",(e)=>{
    const items = e.clipboardData?.items;
    if (!items) return;
    for (const it of items) {
      if (it.type.startsWith("image/")) {
        const f = it.getAsFile();
        if (f) { takeFile(new File([f], "screenshot.png", {type: f.type})); break; }
      }
    }
  });

  function takeFile(file){
    const okTypes = ["application/pdf","image/png","image/jpeg"];
    if (!okTypes.includes(file.type)) { status("Неподдерживаемый тип"); return; }
    sourceFile = file;
    preview.textContent = `${file.name} • ${(file.size/1024/1024).toFixed(2)} MB`;
    parsedItems = [];
    renderTable();
    btnCreate.disabled = true;
    status("Файл готов. Нажмите «Распознать».");
  }

  btnClear.addEventListener("click", ()=>{
    sourceFile = null; sourceKind = null; parsedItems = [];
    fileInput.value = "";
    preview.textContent = "";
    renderTable();
    btnCreate.disabled = true;
    status("Очищено");
  });

  // ====== Парсинг / OCR ======
  btnParse.addEventListener("click", async ()=>{
    if (!sourceFile) { status("Выберите файл"); return; }
    parsedItems = [];
    btnParse.disabled = true; status("Определяю тип…");

    if (sourceFile.type === "application/pdf") {
      const ab = await sourceFile.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({data: ab}).promise;
      // Проверяем наличие текстового слоя на первой странице
      const page1 = await pdf.getPage(1);
      const text1 = await page1.getTextContent();
      const hasText = (text1.items?.length||0) > 0;

      sourceKind = hasText ? "pdf-text" : "pdf-scan";
      status(hasText ? "Читаю PDF-текст…" : "PDF-скан — запускаю OCR…");

      if (hasText) {
        // Собираем текст со всех страниц и парсим
        let fullText = "";
        for (let i=1; i<=pdf.numPages; i++){
          const p = await pdf.getPage(i);
          const tc = await p.getTextContent();
          const pageText = tc.items.map(it=>it.str).join("\n");
          fullText += "\n" + pageText;
        }
        parsedItems = parseTableFromText(fullText);
      } else {
        // Рендерим страницы в canvas и OCR
        for (let i=1; i<=pdf.numPages; i++){
          status(`OCR страница ${i}/${pdf.numPages}…`);
          const p = await pdf.getPage(i);
          const viewport = p.getViewport({scale: 2.0});
          const canvas = document.createElement("canvas");
          canvas.width = viewport.width; canvas.height = viewport.height;
          const ctx = canvas.getContext("2d");
          await p.render({canvasContext: ctx, viewport}).promise;

          const bin = preprocessCanvas(canvas);
          const { data: { text } } = await Tesseract.recognize(bin.toDataURL("image/png"), "rus+eng", { logger: m=>{ if(m.progress) status(`OCR ${Math.round(m.progress*100)}%…`)} });
          const pageItems = parseTableFromText(text, true);
          parsedItems.push(...pageItems);
        }
      }
    } else {
      // image (png/jpg)
      sourceKind = "image";
      status("Готовлю изображение…");
      const img = await loadImageFile(sourceFile);
      const can = document.createElement("canvas");
      can.width = img.naturalWidth; can.height = img.naturalHeight;
      const ctx = can.getContext("2d");
      ctx.drawImage(img,0,0);
      const bin = preprocessCanvas(can);

      status("Делаю OCR…");
      const { data: { text } } = await Tesseract.recognize(bin.toDataURL("image/png"), "rus+eng", { logger: m=>{ if(m.progress) status(`OCR ${Math.round(m.progress*100)}%…`)} });
      parsedItems = parseTableFromText(text, true);
    }

    // Фильтруем мусор
    parsedItems = parsedItems.filter(r => (textNormalize(r.title).length>0) || (r.qtyPacks!=null) || (r.qtyUnits!=null));
    renderTable();
    foundInfo.textContent = parsedItems.length ? `Найдено позиций: ${parsedItems.length}` : "Ничего не найдено";
    btnParse.disabled = false;
    btnCreate.disabled = parsedItems.length === 0;
    status(parsedItems.length ? "Готово. Проверьте таблицу." : "Не удалось извлечь позиции.");
  });

  function preprocessCanvas(srcCanvas){
    // Grayscale + простая бинаризация (OTSU-подобно, но упрощённо)
    const w = srcCanvas.width, h = srcCanvas.height;
    const can = document.createElement("canvas");
    can.width=w; can.height=h;
    const ictx = srcCanvas.getContext("2d");
    const octx = can.getContext("2d");
    const img = ictx.getImageData(0,0,w,h);
    const d = img.data;
    // grayscale
    for (let i=0;i<d.length;i+=4){
      const y = (d[i]*0.299 + d[i+1]*0.587 + d[i+2]*0.114)|0;
      d[i]=d[i+1]=d[i+2]=y;
    }
    // threshold (median)
    const ys = [];
    for (let i=0;i<d.length;i+=4) ys.push(d[i]);
    ys.sort((a,b)=>a-b);
    const thr = ys[(ys.length/2)|0] || 128;
    for (let i=0;i<d.length;i+=4){
      const v = d[i] < thr ? 0 : 255;
      d[i]=d[i+1]=d[i+2]=v;
    }
    octx.putImageData(img,0,0);
    return can;
  }

  function loadImageFile(file){
    return new Promise(res=>{
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.onload=()=>{ URL.revokeObjectURL(url); res(img); };
      img.src=url;
    });
  }

  // ====== Эвристический парсер табличного текста ======
  const HEADER_HINTS = ["артикул","товар","наименование","кол","кол-во","количество","упаковок","шт"];
  function parseTableFromText(txt, fromOcr=false){
    // Нормализация
    const lines = txt.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
    // Автозамены OCR
    const fix = (s)=>{
      return s
        .replace(/О/g,"О") // кириллица О (оставляем)
        .replace(/[^A-Za-zА-Яа-я0-9\-\(\)\.\,\/\s]/g,"")
        .replace(/[\u2013\u2014]/g,"-")
        .replace(/\bупак\b/gi,"упак")
        .replace(/\bшт\b/gi,"шт");
    };
    const arr = [];
    let inBlock = false;
    for (let i=0;i<lines.length;i++){
      const raw = fix(lines[i]);
      const low = raw.toLowerCase();
      // Начало блока — если встречаем строку с большинством ключевиков (шапка)
      const score = HEADER_HINTS.reduce((a,k)=> a + (low.includes(k)?1:0), 0);
      if (score >= 2) { inBlock = true; continue; }
      if (!inBlock) continue;

      // Маркер конца
      if (/^всего\s+наименований/i.test(low)) break;

      // Эвристика: последние 1–2 токена — числа
      const tokens = raw.split(/\s{2,}|\t| {1,}/).filter(Boolean);
      if (!tokens.length) continue;

      // Пробуем выделить правую часть — qty
      let qtyUnits = null, qtyPacks = null, title = raw, article = "";
      // Смотрим справа налево до двух чисел
      let nums = [];
      for (let t = tokens.length-1; t>=0 && nums.length<2; t--){
        const val = numMaybe(tokens[t]);
        if (val!=null) nums.push({idx:t, val});
      }
      if (nums.length>=1) {
        qtyUnits = nums[0].val;
        const cut1 = tokens.slice(0, nums[0].idx).join(" ");
        title = cut1 || raw;
      }
      if (nums.length>=2) {
        qtyPacks = nums[1].val;
        const cut2 = tokens.slice(0, nums[1].idx).join(" ");
        title = cut2 || title;
      }

      // Выделим артикул как «похож на код» (буквы/цифры/дефис, ≥4)
      const mArt = title.match(/([A-Za-zА-Яа-я0-9\-]{4,})/g);
      if (mArt && mArt.length){
        // Берём самый «кодовый» (есть цифры и буквы или дефис)
        const cand = mArt.find(x=> /[0-9]/.test(x) && /[A-Za-zА-Яа-я]/.test(x) || x.includes("-"));
        if (cand) {
          article = cand;
          // Убираем его из title (мягко)
          title = title.replace(cand,"").replace(/\s{2,}/g," ").trim();
        }
      }
      // Отсев мусора — пустые и без количеств?
      if (!title && qtyUnits==null && qtyPacks==null) continue;

      arr.push({
        title: titleNormalize(title),
        article: article||"",
        qtyPacks: qtyPacks,
        qtyUnits: qtyUnits,
        _conf: fromOcr ? 0.6 : 0.98
      });
    }
    return arr;
  }

  function titleNormalize(s){
    return textNormalize(s)
      .replace(/^[\-\.\,]+/,"")
      .replace(/\s{2,}/g," ")
      .trim();
  }

  // ====== Таблица / правки ======
  function renderTable(){
    tbody.innerHTML = "";
    let sp=0, su=0;
    parsedItems.forEach((r,idx)=>{
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td contenteditable="true" class="${(r._conf||1)<0.85 ? "lowconf":""}" data-col="title">${escapeHtml(r.title||"")}</td>
        <td contenteditable="true" data-col="article">${escapeHtml(r.article||"")}</td>
        <td contenteditable="true" class="right" data-col="qtyPacks">${r.qtyPacks ?? ""}</td>
        <td contenteditable="true" class="right" data-col="qtyUnits">${r.qtyUnits ?? ""}</td>
        <td class="right"><button class="btn warn" data-del="${idx}">Удалить</button></td>
      `;
      tbody.appendChild(tr);
      if (r.qtyPacks!=null && !isNaN(r.qtyPacks)) sp += Number(r.qtyPacks);
      if (r.qtyUnits!=null && !isNaN(r.qtyUnits)) su += Number(r.qtyUnits);
    });
    sumPacks.textContent = String(sp);
    sumUnits.textContent = String(su);

    // Обработчики правок
    tbody.querySelectorAll("td[contenteditable]").forEach(td=>{
      td.addEventListener("input", (e)=>{
        const tr = td.closest("tr");
        const rowIdx = Array.from(tbody.children).indexOf(tr);
        const col = td.dataset.col;
        let val = td.textContent;
        if (col==="qtyPacks"||col==="qtyUnits") val = numMaybe(val);
        parsedItems[rowIdx][col] = (col==="title"||col==="article") ? textNormalize(val||"") : val;
        renderTable(); // пересчитать суммы
      });
    });
    tbody.querySelectorAll("button[data-del]").forEach(btn=>{
      btn.addEventListener("click",()=>{
        const i = Number(btn.dataset.del);
        parsedItems.splice(i,1);
        renderTable();
        btnCreate.disabled = parsedItems.length===0;
        foundInfo.textContent = parsedItems.length ? `Найдено позиций: ${parsedItems.length}` : "—";
      });
    });
  }

  function escapeHtml(s){ return (s||"").replace(/[&<>"']/g, m=>({ "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;" }[m])); }

  // ====== Создание задачи ======
  btnCreate.addEventListener("click", async ()=>{
    try{
      const title = textNormalize($("#title").value);
      if (!title) { status("Укажите заголовок"); return; }
      const comment = $("#comment").value || "";
      const assignees = $("#assignees").value.split(",").map(s=>s.trim()).filter(Boolean);

      btnCreate.disabled = true;
      status("Загружаю файл в Cloudinary…");

      // Выбираем resource_type для Cloudinary
      const isPdf = sourceFile?.type === "application/pdf";
      const resourceType = isPdf ? "raw" : "image"; // pdf → raw, картинки → image

      const upRes = await cloudinaryUpload(sourceFile, resourceType);
      if (!upRes?.secure_url) throw new Error("Cloudinary upload failed");

      status("Пишу задачу в Firestore…");
      // files[]
      const fileEntry = {
        url: upRes.secure_url,
        publicId: upRes.public_id,
        type: isPdf ? "pdf" : "image",
        name: sourceFile?.name || (isPdf ? "document.pdf" : "image")
      };

      const items = parsedItems.map(r=>({
        title: r.title || "",
        article: r.article || "",
        qtyPacks: r.qtyPacks ?? null,
        qtyUnits: r.qtyUnits ?? null
      }));

      const docData = {
        title: title,
        comment: buildCommentWithMeta(comment),
        status: "new",
        createdAt: serverTimestamp(),
        files: [fileEntry],
        items: items,
        assigneeIds: assignees,
        source: sourceKind || (isPdf ? "pdf-text" : "image"),
        sourceMeta: {
          userAgent: navigator.userAgent,
          fileName: sourceFile?.name || "",
          fileSize: sourceFile?.size || 0
        }
      };

      const ref = await addDoc(collection(db, "tasks"), docData);

      status("Шлю пуш…");
      await sendNotify(ref.id, assignees);

      status(`Готово: задача ${ref.id}`);
      btnCreate.disabled = false;
      alert("Задача создана!");
    } catch(e){
      console.error(e);
      btnCreate.disabled = false;
      status("Ошибка: " + (e.message||e));
      alert("Ошибка: " + (e.message||e));
    }
  });

  function buildCommentWithMeta(comment){
    // тут можно извлечь «Склад», «Заказ №», «Контрагент» из текста, если нужно
    // Для MVP просто вернём комментарий как есть.
    return comment;
  }

  async function cloudinaryUpload(file, resourceType){
    const url = `https://api.cloudinary.com/v1_1/${CLOUD_NAME}/${resourceType}/upload`;
    const fd = new FormData();
    fd.append("file", file);
    fd.append("upload_preset", UPLOAD_PRESET);
    // Папка принудительно (если в пресете не задана)
    fd.append("folder", "uploads");
    // Подсказка имени
    fd.append("public_id", Date.now() + "_" + (file.name || "source"));

    const resp = await fetch(url, { method:"POST", body: fd });
    if (!resp.ok) throw new Error("Cloudinary HTTP " + resp.status);
    return await resp.json();
  }

  async function sendNotify(taskId, assigneeIds){
    try{
      const resp = await fetch(NOTIFY_URL, {
        method: "POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify({ taskId, assigneeIds })
      });
      // ок если 2xx; если ваш эндпойнт требует секрет — вызовите через ваш прокси (serverless)
      return await resp.json().catch(()=> ({}));
    } catch(e){ console.warn("notify failed", e); }
  }
</script>
</body>
</html>
